# 动态规划

<b>动态规划的特点</b> : 

1. 求某一个问题的最优解(最大、最小值)
2. 整体问题的最优解是依赖各个子问题的最优解
3. 把大问题分解成若干个小问题,这些小问题之间还有相互重叠的更小的子问题
4. 可以用从下往上的顺序先计算小问题的最优解并存储下来,再以此为基础求取最大问题的最优解



>例如, 我们如何把长度为n的绳子剪成若干段,使得得到的各段的长度的乘积最大.

- 以上问题的目标是求剪出的各段绳子长度的成绩最大,也就是求一个问题的最优解.
  - 我们假设,最大成绩为`f(n)`
  - 分为两段时, 剪刀剪在了i位置. 那么有 `f(n) = i * (n-i)`
  - 要得到`f(n)`,那么要同样用最优化的方法把长度为`i`和`n-i`的两段分别剪成若干段,使得它们各自剪出的每段绳子的长度乘积最大.
  - 再大问题分解成小问题的过程中,会有许多子问题重复出现,为了避免重复求解子问题，我们可以用从下往上的顺序先计算小问题的最优解并存储下来,再以此为基础求取大问题的最优解



分析:

>将绳子为n时的最大收益存储在arr中,即 arr[0] = 0, arr[1] = 1; arr[2] =2(不剪); arr[3] = 3(不减)
>
>当n的值大于3时, arr[n] = Math( arr[j] * arr[n-j]);
>
>值得注意的是,当n小于2时,实际的收益是0
>
>n=2, 实际的收益是1 (f(2) = 1 * 1)
>
>n=3, 实际的收益是2( f(3) =  1* 2)

```js
function cut(n) {
    if(n < 2)  return 0;
    if(n == 2) return 1;
    if(n == 3) return 2;
    let arr = [];
    arr[0] = 0; // 分得0时,长度为0
    arr[1] = 1; // 分得1时,作为乘数,可以贡献1
    arr[2] = 2;
    arr[3] = 3; 
    let max = 0;
    for(let i =4; i <= n; i++){
        for(let j = 1; j <= i/2; j++){
            let cur = arr[j]* arr[n-j];
            if(max < cur){
                max = cur
            }
        }
        arr[i] = max;
    }
    max = arr[n];
    arr = null;
    return max;
}
```





