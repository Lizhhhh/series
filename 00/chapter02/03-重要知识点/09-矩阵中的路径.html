<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
      编写一个函数: 从矩阵中找到给定路径, 若存在则返回true, 否则返回false

      思路:
      1. 首先在矩阵中任选一个格子作为路径的起点
      2. 假设矩阵中某个格子的字符为ch,并且这个各自将对应于路径上的第i个字符
      3. 如果路径上的第i个字符不是ch,那么这个格子不可能处在路径上的第i个位置
      4. 如果路径上的第i个字符正好是ch,那么到相邻的格子寻找路径上的第i+1个字符.
      5. 除矩阵边界上的格子之外,其他格子都有4个相邻格子.
      6. 重复这个过程,直到路径上的所有字符串都在矩阵中找到相应的位置

      1. 由于回溯法的递归特性,路径可以被看成一个栈。
      2. 当在矩阵中定位了路径中前n个字符的位置之后,在与第n个字符对应的格子的周围都没有找到第n+1个字符,
      3. 这个时候只好在路径上回到第n-1个字符,重新定位第n个字符
    */

      let arr = [
        ['a', 'b', 't', 'g'],
        ['c', 'f', 'c', 's'],
        ['j', 'd', 'e', 'h']
      ]

      function hasPath(matrix, rows, cols, str){
        if(matrix == null || rows< 1 || cols< 1 || str == null) return false

        let visited = []
        let pathLenth = 0;
        for(let row = 0; row< rows; row++){
          for(let col = 0; col< cols ; col++){
            if(hasPathCore(matrix,rows,cols,row,col,str,pathLength,visited)){
              return true
            }
          }
        }
        return false
      }
      function hasPathCore(matrix,rows, cols, row, col, str, pathLength, visited){
        if(str[pathLength] == '\0') return true
        let hasPath = false
        if(row>=0 && row<rows && col>=0 && col<cols
        ){
          pathLength++
        }
      }
    </script>
  </body>
</html>
